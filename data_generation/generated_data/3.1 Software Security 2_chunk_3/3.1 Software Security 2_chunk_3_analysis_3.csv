input,output
What is the primary purpose of the `printf` function?,"The `printf` function is primarily used to print formatted output to the 'stdout' stream. The 'stdout' stream, or standard output, is the default destination for program output, typically the console or terminal."
Describe the functionality of `fprintf`.,"The `fprintf` function is used to print formatted output to a specified FILE stream. A FILE stream is an abstract source or destination for data, representing files, devices, or other input/output mechanisms, allowing data to be written to a specific file rather than the standard output."
How does `sprintf` differ from `printf`?,"The `sprintf` function differs from `printf` in its output destination. While `printf` prints to the 'stdout' stream, `sprintf` prints formatted output into a string. This means `sprintf` writes characters to a character array (string) in memory, rather than displaying them on the console."
Explain the role of `snprintf`.,"The `snprintf` function prints formatted output into a string with length checking. This is a crucial difference from `sprintf` as it prevents buffer overflows by ensuring that no more than a specified number of characters (including the null terminator) are written to the destination string. Length checking limits the amount of data written, enhancing security."
"What is a `va_arg` structure, and which functions use it for output to `stdout`?","A `va_arg` structure is a mechanism in C for accessing arguments in functions that accept a variable number of arguments (variadic functions). The `vprintf` function uses a `va_arg` structure to print formatted output to 'stdout'. 'stdout' refers to the standard output stream, typically the console."
Identify the functions that print to a FILE stream.,"The functions that print to a FILE stream are `fprintf` and `vfprintf`. A FILE stream is an abstract source or destination for data, representing files, devices, or other input/output mechanisms, allowing data to be written to a specific file rather than the standard output."
Which functions are used for outputting error information?,"The functions used for outputting error information are `err` and `verr`. `err` outputs general error information, while `verr` outputs error information specifically when dealing with a `va_arg` structure, which is used for functions that accept a variable number of arguments."
What is the difference between `err` and `verr`?,"The difference between `err` and `verr` lies in their argument handling. `err` is used to output general error information, typically taking a fixed number of arguments. In contrast, `verr` is designed to output error information when the arguments are provided via a `va_arg` structure, which is used by variadic functions (functions that accept a variable number of arguments)."
Describe the `syslog` function.,"The `syslog` function is used to output information to the syslog facility. The syslog facility is a standard for logging program messages, allowing system administrators to monitor and debug system activities by centralizing log messages from various applications and system components."
List all functions that print into a string.,"The functions that print into a string are `sprintf`, `snprintf`, `vsprintf`, and `vsnprintf`. These functions write formatted data into a character array (string) in memory, rather than directly to a console or file stream."
Which functions provide length checking when printing into a string?,"The functions that provide length checking when printing into a string are `snprintf` and `vsnprintf`. Length checking is a critical security feature that limits the number of characters written to the destination string, preventing buffer overflows by ensuring the string does not exceed its allocated memory."
Explain the purpose of `vprintf` and `vfprintf`.,"`vprintf` and `vfprintf` are variadic versions of `printf` and `fprintf`, respectively. `vprintf` prints formatted output to 'stdout' from a `va_arg` structure, while `vfprintf` prints formatted output to a FILE stream from a `va_arg` structure. A `va_arg` structure allows functions to accept a variable number of arguments."
Provide the description for `warn` and `vwarn`.,"`warn` is used to output warning information, typically to the standard error stream. `vwarn` is similar but outputs warning information specifically when the arguments are provided via a `va_arg` structure, which is used by functions that accept a variable number of arguments."
"When was the format string vulnerability originally noted as a software bug, and by whom?","The format string vulnerability was originally noted as a software bug in 1989. This discovery was made through fuzz testing work conducted at the University of Wisconsin. Fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program."
"How was the format string bug exploited as an attack vector, and when did this occur?","The format string bug was exploited as an attack vector in September 1999. This exploitation became possible because the `snprintf` function could accept user-generated data without a proper format string, which allowed for privilege escalation. Privilege escalation is the act of exploiting a bug, design flaw, or configuration oversight in an operating system or software application to gain elevated access to resources that are normally protected from an application or user."
Explain the role of `snprintf` in the exploitation of format string bugs.,"In the context of format string bug exploitation, `snprintf` played a critical role because it could accept user-generated data without a format string. This allowed attackers to inject malicious format string specifiers, leading to vulnerabilities such as reading or writing arbitrary memory locations, and ultimately enabling privilege escalation. Privilege escalation is the act of gaining elevated access to resources beyond what is normally allowed."
When did the security community become aware of the danger of format string vulnerabilities?,"The security community became aware of the danger posed by format string vulnerabilities in June 2000. This awareness followed the discovery that these bugs could be exploited as an attack vector, leading to serious security implications like privilege escalation."
What has been the trend regarding format string vulnerabilities since June 2000?,"Since June 2000, a significant number of format string vulnerabilities have been discovered in various different applications. This indicates a widespread presence of this type of vulnerability across different software systems following the security community's awareness of its danger."
Analyze the impact of format string vulnerabilities across different applications based on the provided table.,"Based on the provided table, format string vulnerabilities have had severe impacts across various applications, primarily leading to 'remote root' or 'local root' access. For instance, `wu-ftpd 2.*`, `Linux rpc.statd`, and `IRIX telnetd` all suffered 'remote root' impacts, while `NLS / locale`, `screen`, `BSD chpass`, and `OpenBSD fstat` experienced 'local root' impacts. Some applications like `Qualcomm Popper 2.53` and `Apache + PHP3` resulted in 'remote user' impact. 'Remote root' implies an attacker gaining full control over a system from a network, and 'local root' implies an attacker gaining full control from the local machine."
"Identify applications where format string vulnerabilities led to ""remote root"" impact.","Format string vulnerabilities led to ""remote root"" impact in the following applications: `wu-ftpd 2.*`, `Linux rpc.statd`, and `IRIX telnetd`. ""Remote root"" signifies that an attacker can gain the highest level of administrative privileges on a system over a network connection."
"Which applications experienced ""local root"" impact due to format string vulnerabilities?","The applications that experienced ""local root"" impact due to format string vulnerabilities include `NLS / locale`, `screen`, `BSD chpass`, and `OpenBSD fstat`. ""Local root"" means an attacker can gain the highest level of administrative privileges on a system from a local user account."
Who discovered the format string vulnerability in `wu-ftpd 2.*` and what was its impact?,"The format string vulnerability in `wu-ftpd 2.*` was discovered by `security.is`. The impact of this vulnerability was ""remote root"", meaning an attacker could gain full administrative control over the system from a remote location, and it was vulnerable for more than 6 years."
Describe the impact and discovery of the format string vulnerability in `IRIX telnetd`.,"The format string vulnerability in `IRIX telnetd` was discovered by `LSD`. The impact of this vulnerability was ""remote root"", indicating that an attacker could gain full administrative control over the system from a remote location. This vulnerability persisted for more than 8 years."
What was the impact of the format string vulnerability found by `security.is` in `Qualcomm Popper 2.53`?,"The format string vulnerability found by `security.is` in `Qualcomm Popper 2.53` had an impact of ""remote user"". This means an attacker could gain unauthorized user-level access to the system from a remote location, and it was vulnerable for more than 3 years."
What are the primary strategies to fix format string vulnerabilities?,"The primary strategies to fix format string vulnerabilities involve limiting the ability of attackers to control the format string. These strategies include using hard-coded format strings, avoiding the use of the `%n` format specifier, and leveraging compiler support to match `printf` arguments with the format string. Hard-coded format strings are literal strings defined in the code, not derived from user input."
"Explain the concept of ""hard-coded format strings"" as a fix.","As a fix for format string vulnerabilities, ""hard-coded format strings"" refers to the practice of using literal string constants directly embedded in the source code for functions like `printf`, rather than using strings that can be influenced or provided by user input. This prevents an attacker from injecting malicious format specifiers into the format string, thereby controlling the program's behavior."
Why should `%n` not be used to prevent format string vulnerabilities?,"The `%n` format specifier should not be used to prevent format string vulnerabilities because it writes the number of characters written so far by the `printf` function into an integer variable whose address is provided as an argument. This capability can be exploited by attackers to write arbitrary values to arbitrary memory locations, leading to memory corruption and potential code execution."
How can compiler support help in mitigating format string vulnerabilities?,"Compiler support can help mitigate format string vulnerabilities by providing warnings or errors when there is a mismatch between the format string specifiers and the types or number of arguments passed to functions like `printf`. This static analysis helps developers identify and correct potential vulnerabilities before the code is deployed, ensuring that format strings are correctly used and not susceptible to malicious input."
Analyze the provided C code snippet to identify the vulnerable line.,"In the provided C code snippet, the vulnerable line is `printf(user_input);`. This line is vulnerable because it directly uses `user_input` (a string read from standard input) as the format string for `printf`. If `user_input` contains malicious format specifiers, an attacker can exploit this to read from or write to arbitrary memory locations, leading to security breaches."
How is the vulnerable `printf` call in the example fixed?,"The vulnerable `printf` call, `printf(user_input);`, is fixed by changing it to `printf(""%s\n"", user_input);`. This modification ensures that the format string `""%s\n""` is hard-coded, and `user_input` is treated as a string argument to be printed, rather than being interpreted as the format string itself. The `%s` specifier correctly handles `user_input` as a string, and `\n` adds a newline character."
What is the danger of `printf(user_input)`?,"The danger of `printf(user_input)` is that if `user_input` contains format specifiers (e.g., `%x`, `%s`, `%n`), the `printf` function will interpret them as part of its format string. An attacker can inject malicious format specifiers to read from arbitrary memory locations (e.g., `%x` to dump stack contents) or write to arbitrary memory locations (e.g., `%n` to overwrite return addresses), leading to information disclosure, denial of service, or arbitrary code execution. This is a format string vulnerability."
"Define a ""format string"" in the context of `printf`.","In the context of `printf`, a ""format string"" is a character string that contains zero or more directives. These directives include ordinary characters (which are copied to the output stream unchanged) and conversion specifications (which fetch arguments from the function's parameter list and format them for output). For example, in `printf(""%s\n"", user_input)`, `""%s\n""` is the format string, and `%s` is a conversion specification."
How do integers differ in mathematics versus a computer system?,"In mathematics, integers form an infinite set, meaning there is no upper or lower bound to their values. In contrast, in a computer system, integers are represented in binary using a fixed length (precision). This fixed length means there is only a finite number of ""integers"" that can be represented, imposing maximal and minimal value limits."
Explain how integers are represented in a computer system.,"In a computer system, integers are represented in binary, which is a base-2 numeral system using only 0s and 1s. This representation uses a fixed length, also known as precision, which determines the number of bits allocated for storing the integer. Due to this fixed length, there is a finite number of distinct integer values that can be represented."
"What is ""precision"" in the context of integer representation?","In the context of integer representation, ""precision"" refers to the fixed length (number of bits) used to store an integer in a computer system. For example, a 32-bit integer has a precision of 32 bits. This fixed length dictates the range of values an integer can hold, meaning there is only a finite number of integers that can be represented."
How are signed integers represented in a computer system?,"Signed integers in a computer system are typically represented using two's complement notation. In this representation, the Most Significant Bit (MSB) indicates the sign of the integer: an MSB of 0 signifies a positive integer, while an MSB of 1 signifies a negative integer. Two's complement allows for efficient arithmetic operations with both positive and negative numbers."
Define the Most Significant Bit (MSB) and its role in signed integer representation.,"The Most Significant Bit (MSB) is the bit position in a binary number that has the greatest value. In the context of signed integer representation using two's complement, the MSB plays a crucial role as the sign bit: if the MSB is 0, the integer is positive; if the MSB is 1, the integer is negative."
What does an MSB of 0 indicate for a signed integer?,"For a signed integer represented using two's complement, an Most Significant Bit (MSB) of 0 indicates that the integer is a positive integer. The remaining bits represent the magnitude of the positive value."
What does an MSB of 1 indicate for a signed integer?,"For a signed integer represented using two's complement, an Most Significant Bit (MSB) of 1 indicates that the integer is a negative integer. The remaining bits, along with the MSB, form the two's complement representation of the negative value."
"Define ""Integer Overflow"".","Integer overflow occurs when an operation causes its integer operand to increase beyond its maximal representable value or decrease below its minimal representable value. When this happens, the result of the operation is no longer correct, as the value 'wraps around' to the opposite end of the integer's range."
"Explain ""Unsigned overflow"".","Unsigned overflow occurs when an arithmetic operation on an unsigned integer produces a result that is outside the range of values that can be represented by its fixed binary length. In such cases, the binary representation cannot correctly hold the integer value, and the result typically wraps around to a small value (e.g., `UINT_MAX + 1` becomes `0`)."
"Explain ""Signed overflow"".","Signed overflow occurs when an arithmetic operation on a signed integer produces a result that is outside the range of values that can be represented by its fixed binary length. Specifically, a value is carried over to the sign bit, causing the number to unexpectedly change from positive to negative or vice versa (e.g., `INT_MAX + 1` becomes `INT_MIN`)."
What are the possible operations that can lead to integer overflow?,"The possible operations that can lead to integer overflow are arithmetic operations and type conversion. Arithmetic operations include addition, subtraction, multiplication, and division, where the result exceeds the maximum or falls below the minimum representable value. Type conversion can lead to overflow if a value is converted to a data type with a smaller range."
What are the consequences of integer overflow?,"Integer overflow is difficult to spot and can lead to other types of bugs, frequently buffer overflow. The primary consequence is that the results of computations become incorrect, which can lead to unpredictable program behavior, security vulnerabilities, or system crashes. A buffer overflow occurs when a program attempts to write data beyond the boundaries of a fixed-length buffer, potentially corrupting adjacent memory."
How do mathematical facts like `a+b>a` and `a-b<a` for `b>0` relate to binary represented integers?,"Mathematical facts such as `a+b>a` and `a-b<a` for `b>0` are no longer universally true for binary represented integers in computer systems due to the finite range of values they can hold. When an arithmetic operation results in a value exceeding this range (integer overflow), the value wraps around, causing these mathematical inequalities to fail. For example, `INT_MAX + 1` does not result in a value greater than `INT_MAX` but instead wraps to `INT_MIN`."
Analyze the behavior of `unsigned int u1 = UINT_MAX; u1++;` in C.,"When `unsigned int u1 = UINT_MAX; u1++;` is executed in C, `u1` is initialized to the maximum possible value for an unsigned integer (`UINT_MAX`). Incrementing `u1` by one (`u1++`) causes an unsigned integer overflow. As unsigned integers wrap around, the value of `u1` becomes `0` after the increment, which is `4,294,967,295` for `UINT_MAX` followed by `0`."
Explain the result of `unsigned int u2 = 0; u2--;` in C.,"When `unsigned int u2 = 0; u2--;` is executed in C, `u2` is initialized to `0`. Decrementing `u2` by one (`u2--`) causes an unsigned integer underflow. Since unsigned integers wrap around, the value of `u2` becomes `UINT_MAX` (the maximum possible value for an unsigned integer) after the decrement, which is `4,294,967,295`."
Describe what happens when `signed int s1 = INT_MAX; s1++;` is executed.,"When `signed int s1 = INT_MAX; s1++;` is executed, `s1` is initialized to the maximum possible value for a signed integer (`INT_MAX`). Incrementing `s1` by one (`s1++`) causes a signed integer overflow. Due to two's complement representation, the value wraps around from `INT_MAX` to `INT_MIN` (the minimum possible value for a signed integer), which is `-2,147,483,648`."
What is the outcome of `signed int s2 = INT_MIN; s2--;`?,"When `signed int s2 = INT_MIN; s2--;` is executed, `s2` is initialized to the minimum possible value for a signed integer (`INT_MIN`). Decrementing `s2` by one (`s2--`) causes a signed integer underflow. Due to two's complement representation, the value wraps around from `INT_MIN` to `INT_MAX` (the maximum possible value for a signed integer), which is `2,147,483,647`."
Define `UINT_MAX` and `INT_MAX` in the context of C programming.,`UINT_MAX` is a macro defined in `<limits.h>` that represents the maximum value an `unsigned int` can hold. `INT_MAX` is also a macro defined in `<limits.h>` that represents the maximum value a `signed int` can hold. These values are system-dependent but typically correspond to the largest number representable by the allocated bits for their respective types.
Define `INT_MIN` in the context of C programming.,"`INT_MIN` is a macro defined in `<limits.h>` that represents the minimum value a `signed int` can hold. This value is system-dependent but typically corresponds to the smallest negative number representable by the allocated bits for a signed integer, usually `-INT_MAX - 1` in two's complement systems."
Why does `u1++` result in `0` when `u1` is `UINT_MAX`?,"When `u1` is `UINT_MAX` and `u1++` is executed, it results in `0` due to unsigned integer overflow. Unsigned integers wrap around upon exceeding their maximum representable value. Conceptually, `UINT_MAX + 1` becomes `0` because the carry bit generated by the addition is discarded, effectively resetting the value to the lowest possible unsigned integer."
Why does `s1++` result in a negative number when `s1` is `INT_MAX`?,"When `s1` is `INT_MAX` and `s1++` is executed, it results in a negative number (`INT_MIN`) due to signed integer overflow. In two's complement representation, incrementing the maximum positive value causes the Most Significant Bit (MSB) to flip from 0 to 1, which changes the sign of the number from positive to negative, effectively wrapping around to the minimum negative value."
Explain how incorrect length checking can lead to a buffer overflow.,"Incorrect length checking can lead to a buffer overflow if the calculation used to determine the buffer's capacity or the amount of data to be written is flawed, especially if it involves integer arithmetic that can overflow. If an integer overflow occurs in the length calculation, the computed length might appear to be within the buffer's bounds, while the actual intended length is much larger. This causes functions like `strncpy` or `strncat` to write more data than the buffer can hold, corrupting adjacent memory and leading to a buffer overflow."
Analyze the `if (len1 + len2 + 1 <= sizeof(buf))` condition in the `combine` function.,"The condition `if (len1 + len2 + 1 <= sizeof(buf))` in the `combine` function is intended to prevent buffer overflow by checking if the combined length of `s1`, `s2`, and a null terminator (`+ 1`) fits within `buf`. However, this check is vulnerable to integer overflow. If `len1 + len2 + 1` exceeds the maximum value an `unsigned int` can hold, it will wrap around to a smaller value, potentially making the condition `true` even when the actual sum is much larger than `sizeof(buf)`, thus bypassing the length check."
How can `len1 + len2 + 1` lead to an integer overflow in the provided example?,"In the provided example, `len1 + len2 + 1` can lead to an integer overflow if `len2` is set to `UINT_MAX` (the maximum unsigned integer value). When `len1` (e.g., 10) is added to `UINT_MAX`, and then `1` is added, the sum `10 + UINT_MAX + 1` will exceed the maximum representable value for an `unsigned int`. This causes the sum to wrap around, resulting in a small value (e.g., `10`), which then incorrectly satisfies the length checking condition `10 < 128`."
What is the consequence if `len1 + len2 + 1` overflows and the condition `len1 + len2 + 1 <= sizeof(buf)` evaluates to true?,"If `len1 + len2 + 1` overflows and the condition `len1 + len2 + 1 <= sizeof(buf)` evaluates to true, it means the length check has been bypassed. The program will then proceed to execute `strncpy` and `strncat` with an effectively much larger intended length than the buffer `buf` can actually hold. This will lead to a buffer overflow, where data is written beyond the allocated memory for `buf`, potentially corrupting adjacent data or leading to arbitrary code execution."
Describe the role of `strncpy` and `strncat` in the buffer overflow scenario.,"In the buffer overflow scenario, `strncpy` and `strncat` are the functions that perform the actual memory writes. `strncpy` copies a specified number of characters from a source string (`s1`) to a destination buffer (`buf`), and `strncat` appends a specified number of characters from another source string (`s2`) to the end of `buf`. If the length check is bypassed due to integer overflow, these functions will attempt to write more data than `buf` can accommodate, causing a buffer overflow by writing past `buf`'s boundary."
"In the example, what specific values of `len1` and `len2` are used to demonstrate the vulnerability?","In the example demonstrating the vulnerability, `len1` is set to `10`, and `len2` is set to `UINT_MAX`. These specific values are chosen to trigger an integer overflow in the length calculation `len1 + len2 + 1`, which then bypasses the intended length check and leads to a buffer overflow."
Define `sizeof(buf)` in the context of the example.,"In the context of the example, `sizeof(buf)` refers to the total size in bytes of the `buf` array. Since `buf` is declared as `char buf[128];`, `sizeof(buf)` would evaluate to `128`. This value represents the maximum capacity of the buffer that the length check is designed to protect."
What is `char buf[128];` doing in the example?,"In the example, `char buf[128];` declares a character array named `buf` with a fixed size of 128 bytes. This array serves as a buffer in memory, intended to store combined string data. It is the target buffer for `strncpy` and `strncat` operations within the `combine` function, and its size (`128`) is used in the length checking condition."
How does `malloc` relate to the `s1` and `s2` pointers in the `main` function?,"In the `main` function, `malloc` is used to dynamically allocate memory for the `s1` and `s2` pointers. Specifically, `char *s1 = (char *)malloc(len1 * sizeof(char));` and `char *s2 = (char *)malloc(len2 * sizeof(char));` allocate blocks of memory of size `len1` and `len2` bytes, respectively, for `s1` and `s2`. These dynamically allocated buffers are the source strings that will be copied into `buf` by `strncpy` and `strncat`."
What is the ultimate outcome of the `combine` function call with `len2 = UINT_MAX`?,"The ultimate outcome of the `combine` function call with `len2 = UINT_MAX` is a buffer overflow. Due to the integer overflow in the length check `len1 + len2 + 1`, the condition `len1 + len2 + 1 <= sizeof(buf)` is incorrectly evaluated as true. This allows `strncpy` and `strncat` to be executed, attempting to copy a massive amount of data (effectively `len1 + UINT_MAX` characters) into `buf`, which only has a capacity of 128 bytes. This overwrites memory beyond `buf`'s boundaries, leading to a buffer overflow."
What does the 'years' column in the vulnerability table represent?,"The 'years' column in the vulnerability table represents the duration, in years, for which a specific application was vulnerable to the listed format string bug. For example, `wu-ftpd 2.*` was vulnerable for more than 6 years, and `IRIX telnetd` for more than 8 years. A '?' indicates that the duration is unknown or not specified in the table."
"Which entity discovered vulnerabilities leading to ""local root"" access?","The entities that discovered vulnerabilities leading to ""local root"" access include `CORE SDI` (for `NLS / locale`), `Jouko PynnÅnen` (for `screen`), `TESO` (for `BSD chpass`), and `ktwo` (for `OpenBSD fstat`). ""Local root"" means an attacker gains the highest level of administrative privileges on a system from a local user account."
Compare the impact of vulnerabilities found by `security.is` versus `CORE SDI`.,"Vulnerabilities found by `security.is` primarily resulted in ""remote root"" or ""remote user"" impacts, affecting applications like `wu-ftpd 2.*`, `Linux rpc.statd`, `IRIX telnetd`, and `Qualcomm Popper 2.53`. In contrast, the vulnerability found by `CORE SDI` (in `NLS / locale`) led to a ""local root"" impact. This indicates `security.is` focused on vulnerabilities exploitable remotely, often leading to full system control, while `CORE SDI` identified a vulnerability requiring local access but still granting full administrative privileges."
What is two's complement representation?,"Two's complement is a mathematical operation on binary numbers and is a method of signed number representation in computing. It allows for the representation of both positive and negative integers using binary digits, where the Most Significant Bit (MSB) indicates the sign (0 for positive, 1 for negative), and negative numbers are represented by inverting all bits of the positive counterpart and adding one."
How does the binary representation of integers impact their mathematical properties?,"The binary representation of integers in a computer system, with its fixed length (precision), fundamentally impacts their mathematical properties. Unlike mathematical integers which form an infinite set, computer integers have finite maximal and minimal values. This limitation means that standard mathematical properties, such as `a+b>a` for `b>0`, may not hold true due to integer overflow or underflow, where values wrap around the representable range, leading to incorrect results."
Why is integer overflow difficult to spot?,"Integer overflow is difficult to spot because it often doesn't immediately cause a program crash or an obvious error. Instead, it silently produces incorrect numerical results that can propagate through calculations, leading to subtle bugs, unexpected program behavior, or security vulnerabilities like buffer overflows, which may only manifest much later or under specific, hard-to-reproduce conditions."
How does the `printf` format specifier `%u` differ from `%d` in the context of integer overflow examples?,"In the context of integer overflow examples, the `printf` format specifier `%u` is used to print an `unsigned int` value, while `%d` is used to print a `signed int` value. This distinction is crucial because `unsigned int` values wrap around from `UINT_MAX` to `0` on overflow/underflow, whereas `signed int` values wrap around from `INT_MAX` to `INT_MIN` (or vice versa), changing their sign. Using the correct specifier ensures the value is interpreted and displayed according to its intended type and behavior during overflow."
