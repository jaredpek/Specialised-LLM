input,output
What are the ways an attacker can exploit StackGuard?,"An attacker can exploit StackGuard in two primary ways. First, they can obtain the canary's value, which is a security token used to detect stack buffer overflows. This value can then be used to overwrite the canary on the stack without altering its value, effectively bypassing the protection. This can be achieved through a format string vulnerability, which allows an attacker to print values from the stack (e.g., using %x), or by using a brute-force technique to guess the canary's value. Second, an attacker can overwrite the return address in the stack without touching the canary. This is also facilitated by format string vulnerabilities, which allow writing to any memory location, not necessarily consecutively with the buffer (e.g., using %n). It's important to note that heap overflows do not overwrite a stack canary."
Explain how a format string vulnerability can be used to attack StackGuard.,"A format string vulnerability can be exploited in two main ways against StackGuard. Firstly, it allows an attacker to print out values from the stack, such as the canary's value, by using format specifiers like `%x`. Once the canary's value is known, the attacker can use it to overwrite the canary on the stack without changing its value, thus bypassing StackGuard's protection. Secondly, format string vulnerabilities can be used to write to arbitrary memory locations, including the return address on the stack, without needing to be in a contiguous buffer. This is often achieved using format specifiers like `%n`, which writes the number of bytes printed so far to a memory address specified by the corresponding argument."
How does an attacker use brute-force to bypass StackGuard?,"An attacker can bypass StackGuard using a brute-force technique to guess the canary's value. The canary is a security token placed on the stack to detect buffer overflows. If the attacker can repeatedly attempt to overwrite the canary and check if the program crashes or continues execution, they can eventually deduce the correct canary value. Once the correct value is known, the attacker can then use it to overwrite the canary on the stack without changing its value, thereby preventing StackGuard from detecting the overflow and allowing them to proceed with their attack, such as overwriting the return address."
Can an attacker overwrite the return address in the stack without affecting the canary when using StackGuard?,"Yes, an attacker can overwrite the return address in the stack without touching the canary when using StackGuard. This is possible through methods like format string vulnerabilities, which allow writing to any memory location, not necessarily consecutively with the buffer (e.g., using `%n`). While StackGuard protects the canary itself, it does not inherently prevent the return address from being overwritten if the attacker can find a way to manipulate memory addresses, especially if the canary's value is not compromised."
What is a Shadow Stack and how does it work?,"A Shadow Stack is a security mechanism designed to protect against control-flow hijacking attacks by maintaining a separate copy of the stack in memory. During a function call, the return address (EIP - Instruction Pointer) is pushed onto both the main stack and the shadow stack. Upon function return, the system checks if the return address on the top of the shadow stack matches the return address on the main stack. If there is a discrepancy, it indicates a potential attack, and the program is terminated. This ensures that any modification to the return address on the main stack will be detected."
How does a Shadow Stack detect attacks?,"A Shadow Stack detects attacks by maintaining a duplicate copy of the return addresses. When a function is called, the return address (EIP) is pushed onto both the regular stack and the shadow stack. When the function is about to return, the system compares the return address on the top of the shadow stack with the return address on the regular stack. If these two addresses do not match, it signifies that the return address on the regular stack has been tampered with, indicating an attack. In such a case, the program is terminated to prevent further malicious execution."
What hardware support is required for Shadow Stack?,"Shadow Stack requires hardware support to function effectively. One such technology is Intel CET (Control-flow Enforcement Technology). This technology introduces a new register called SSP (Shadow Stack Pointer), which manages the shadow stack. Additionally, shadow stack pages are marked with a special 'shadow stack' attribute. This attribute ensures that only specific instructions, namely 'call' and 'ret' (return), can read from or write to these designated shadow stack pages, enhancing the security and integrity of the shadow stack."
What is Intel CET and its role in Shadow Stack?,"Intel CET stands for Control-flow Enforcement Technology. It is a hardware-assisted security feature that supports the implementation of a Shadow Stack. Within Intel CET, a new register known as the SSP (Shadow Stack Pointer) is introduced. This SSP is crucial for managing the shadow stack, which is a secondary stack used to store return addresses. Furthermore, CET enables the marking of memory pages as 'shadow stack' pages, restricting access to these pages to only 'call' and 'ret' instructions, thereby protecting the integrity of the return addresses stored there."
What is StackShield?,"StackShield is a GNU C compiler extension designed to protect the return address on the stack. Its core principle is to separate control information, specifically the return address, from the program's data. When a function is called, StackShield copies the return address (EIP) to a secure, non-overflowable area. Upon function return, this original return address is restored. Even if the return address on the main stack is altered by an attacker, StackShield ensures that the correct, original return address is used for the jump back, thus mitigating return-oriented programming (ROP) attacks."
How does StackShield protect the return address?,"StackShield protects the return address by separating it from the data on the stack. When a function is called, StackShield copies the return address (EIP) to a safe, non-overflowable memory region. This prevents attackers from overwriting it through buffer overflows on the main stack. When the function is about to return, StackShield restores the original return address from this secure location back to the stack. Consequently, even if the return address on the stack has been corrupted, the program will still use the correct, original address to return, thereby neutralizing the attack."
"What is the limitation of StackGuard, Shadow Stack, and StackShield regarding pointer protection?","A common limitation of StackGuard, Shadow Stack, and StackShield is that they primarily focus on protecting the return address, but not other important pointers within a program. While these mechanisms are effective against attacks that target the return address, they do not offer protection against attacks that exploit vulnerabilities in function pointers or other critical data pointers. This leaves a significant attack surface open for attackers who can hijack function pointers to redirect program execution."
Explain the concept of hijacking a function pointer.,"Hijacking a function pointer is an attack technique where an attacker manipulates a program's memory to alter the value of a function pointer. A function pointer is a variable that stores the memory address of a function. If an attacker can overwrite a function pointer with the address of malicious code or another function, they can redirect the program's execution flow. This is a common attack vector, especially when direct return address overwrites are prevented by security mechanisms like canaries, as it bypasses those protections by targeting a different type of control flow mechanism."
How can an attacker hijack a function pointer even if the return address is protected?,"Even if the return address is protected by mechanisms like canaries, an attacker can still hijack a function pointer. This is because StackGuard, Shadow Stack, and StackShield primarily focus on securing the return address, not other critical pointers. If a program contains a vulnerability, such as a buffer overflow, that allows an attacker to overwrite data on the stack, they can target a function pointer stored in that stack frame. By overwriting the function pointer with the address of malicious code or another function, the attacker can redirect program execution when that function pointer is invoked, bypassing the return address protection."
What is PointGuard?,"PointGuard is a compiler-based approach designed to protect function pointers from being overwritten. It operates by encrypting all pointers while they are stored in memory and decrypting them only when they are loaded into CPU registers for use. This process involves generating a secret key randomly for each program launch. Pointer encryption involves XORing the pointer with this key, and pointer decryption reverses this process. This ensures that pointers are in their original, unencrypted form only during active use within the CPU, significantly minimizing the window of vulnerability for attackers."
How does PointGuard protect function pointers?,"PointGuard protects function pointers by employing encryption and decryption techniques. When a pointer is stored in memory, PointGuard encrypts it using a randomly generated secret key, typically through an XOR operation. This encrypted pointer is unintelligible to an attacker attempting to overwrite it. Only when the pointer is needed for execution, such as when a function call is made through a function pointer, is it decrypted by the CPU using the same secret key. This decryption happens just before the pointer is used, ensuring that the pointer is in its original, functional form only for the brief period of its actual use, thereby preventing malicious overwrites."
What is the role of the secret key in PointGuard?,"In PointGuard, a secret key plays a crucial role in protecting function pointers. This secret key is randomly generated each time a program is launched. It is used for both encrypting pointers before they are stored in memory and decrypting them when they are loaded into CPU registers for execution. The encryption process typically involves XORing the pointer with the secret key. Without knowledge of this correct secret key, an attacker cannot generate the correct encrypted form of a malicious function address to overwrite a legitimate pointer, thus preventing them from hijacking the program's control flow."
Explain the process of pointer encryption and decryption in PointGuard.,"In PointGuard, pointer encryption and decryption are key to protecting function pointers. When a pointer is to be stored in memory, it undergoes encryption. This typically involves an XOR operation with a secret key that is randomly generated for each program execution. The result is an encrypted pointer stored in memory. Later, when the CPU needs to use this pointer, for instance, to call a function, it first performs decryption. This decryption process also uses the same secret key, reversing the XOR operation to restore the pointer to its original, unencrypted form. This ensures the pointer is only in its usable state for the brief duration of its actual execution, minimizing the attack window."
What is Pointer Authentication?,"Pointer Authentication is a security feature introduced in the ARM architecture to protect function pointers. It works by appending a cryptographic signature, known as a Pointer Authentication Code (PAC), to pointers. The CPU can then verify the integrity of these pointers before they are used. This process involves generating a PAC when a pointer is created or updated, using a cryptographic hash of the pointer's value and a secret key. This PAC is then embedded into the unused high-order bits of the pointer. Before the pointer is used, the system recalculates the PAC and compares it to the stored PAC to ensure its integrity."
How does Pointer Authentication work on ARM architecture?,"Pointer Authentication on ARM architecture protects function pointers by appending a cryptographic signature called a Pointer Authentication Code (PAC). When a pointer is created or updated, a PAC is generated using a cryptographic hash of the pointer's value and a secret key. This PAC is then embedded into the unused high-order bits of the pointer. Before the pointer is utilized by the CPU, the system performs Pointer Verification. This involves recalculating the PAC based on the pointer's current value and the secret key, and then comparing this recalculated PAC with the one stored within the pointer. The pointer can only be used if these PAC values match, ensuring its integrity."
What is a Pointer Authentication Code (PAC)?,"A Pointer Authentication Code (PAC) is a cryptographic signature appended to pointers as part of the Pointer Authentication security feature, particularly in the ARM architecture. It is generated using a cryptographic hash of the pointer's original value combined with a secret key. This PAC is then embedded into the unused high-order bits of the pointer. The purpose of the PAC is to allow the system to verify the integrity of the pointer. Before the pointer is used, the system recalculates the PAC and compares it to the stored PAC. If they match, the pointer is considered valid and can be used; otherwise, it indicates tampering."
Explain the process of Pointer Signing and Verification.,"Pointer Signing and Verification are the two core steps in Pointer Authentication. Pointer Signing occurs when a pointer is created or updated. During this phase, a Pointer Authentication Code (PAC) is generated using a cryptographic hash of the pointer's value and a secret key. This PAC is then embedded into the unused high-order bits of the pointer. Pointer Verification takes place just before the pointer is used by the CPU. The system recalculates the PAC using the pointer's current value and the secret key, and then compares this newly generated PAC with the one stored within the pointer. The pointer is only considered valid and usable if the two PACs match."
What is the significance of the secret key in Pointer Authentication?,"The secret key is fundamental to Pointer Authentication. It is used in conjunction with the pointer's value to generate the Pointer Authentication Code (PAC) during the signing process. This same secret key is then used by the CPU during verification to recalculate the PAC. Without knowledge of the correct secret key, an attacker cannot generate a valid PAC for a maliciously altered function pointer. Consequently, the pointer verification step will fail, preventing the attacker from successfully hijacking the program's control flow by using a forged pointer."
What are the steps involved in a typical Stack Smashing Attack?,"A typical Stack Smashing Attack involves several key steps. First, the attacker must find a buffer overflow vulnerability in the program. This is a flaw where a program writes more data to a buffer than it can hold. Second, the attacker injects malicious code, known as shellcode, into a known memory address. Third, the attacker exploits the buffer overflow vulnerability to overwrite the Instruction Pointer (EIP) with the memory address of the injected shellcode. Fourth, when the vulnerable function returns, instead of returning to the legitimate next instruction, it returns to the shellcode. Finally, the shellcode begins to execute, allowing the attacker to gain control of the program."
What is shellcode in the context of a Stack Smashing Attack?,"Shellcode is a small piece of code, typically written in assembly language, that an attacker injects into a vulnerable program during a stack smashing attack. Its purpose is to be executed by the compromised program to achieve the attacker's goals, such as opening a command shell on the target system, hence the name 'shellcode'. In a stack smashing attack, the shellcode is placed in memory, and the attacker then overwrites the return address on the stack to point to the location of this shellcode, causing it to be executed when the function returns."
How does overwriting EIP contribute to a Stack Smashing Attack?,"Overwriting the Instruction Pointer (EIP) is a critical step in a Stack Smashing Attack. EIP holds the memory address of the next instruction to be executed by the CPU. In a stack smashing attack, after a buffer overflow vulnerability is exploited, the attacker replaces the legitimate return address stored on the stack with the memory address of their injected shellcode. When the function returns, the CPU fetches the return address from the stack, which is now the address of the shellcode. This causes the program's execution flow to be diverted to the attacker's code, rather than continuing normally."
What is the solution proposed to mitigate Stack Smashing Attacks?,"A primary solution proposed to mitigate Stack Smashing Attacks is the implementation of Non-Executable Memory. This security feature prevents the CPU from executing code located in memory regions that are marked as writable. In a stack smashing attack, attackers inject shellcode into a writable memory region (like the stack) and then redirect execution to it. By making these writable regions non-executable, the system prevents the injected malicious code from running, even if the attacker successfully overwrites the return address."
Explain the concept of Non-Executable Memory.,"Non-Executable Memory is a security mechanism that prevents code from being executed in memory regions designated for data. The key idea is that attackers often inject malicious code (shellcode) into writable memory areas, such as the stack or heap, and then redirect program execution to this injected code. By configuring these writable memory regions to be non-executable, the system effectively thwarts such attacks. Even if an attacker manages to place malicious code in memory, the CPU will refuse to execute it, thereby preventing the attack from succeeding. This is implemented through features like Data Execution Prevention (DEP) on Windows and ExecShield on Linux."
How does Non-Executable Memory prevent stack smashing attacks?,"Non-Executable Memory prevents stack smashing attacks by ensuring that the stack, which is typically a writable memory region, cannot be used to execute code. In a stack smashing attack, the attacker injects malicious code (shellcode) into a buffer on the stack and then overwrites the return address to point to this shellcode. If the stack is marked as non-executable, the CPU will refuse to execute the shellcode even if the return address is successfully redirected. This breaks the attack chain, as the malicious code cannot be run."
What are the operating system features that implement Non-Executable Memory?,"Operating systems implement Non-Executable Memory through specific features. On Windows, this is known as Data Execution Prevention (DEP). On Linux, a similar mechanism is called ExecShield. These features allow the system to mark memory regions as either executable or non-executable. By default, data segments like the stack and heap are often configured as non-executable, while code segments are executable. This separation prevents attackers from executing injected code in data-holding memory areas."
What hardware support is required for Non-Executable Memory?,"Non-Executable Memory relies on hardware support to enforce its policy. Modern processors include specific features that enable this functionality. For instance, the AMD64 architecture supports Non-Execute (NX-bit), Intel x86 processors support the Execute Disable (XD-bit), and ARM processors support the Execute Never (XN-bit). These bits are typically managed at the hardware level through Page Table Entries (PTEs). Each PTE has an attribute that controls whether the corresponding memory page is executable or non-executable, allowing the operating system to enforce the Non-Executable Memory policy."
How do Page Table Entries (PTEs) relate to Non-Executable Memory?,"Page Table Entries (PTEs) are fundamental to the implementation of Non-Executable Memory. A PTE is a data structure used by the memory management unit (MMU) to store information about a virtual memory page. Crucially, each PTE contains an attribute that dictates whether the corresponding memory page is executable or non-executable. When the CPU accesses memory, it consults the PTE. If the PTE marks the page as non-executable and the access is an attempt to execute code from that page, the CPU will generate a fault, preventing the execution and enforcing the Non-Executable Memory policy."
"What is the purpose of the NX-bit, XD-bit, and XN-bit?","The NX-bit (No-Execute bit) on AMD64 processors, the XD-bit (Execute Disable bit) on Intel x86 processors, and the XN-bit (Execute Never bit) on ARM processors all serve the same purpose: to enable Non-Executable Memory. These are hardware features that allow the processor to distinguish between memory pages that can be used to store and execute code, and those that can only store data. By setting these bits in the Page Table Entries (PTEs), the operating system can instruct the CPU to prevent code execution from specific memory regions, thereby enhancing security against code injection attacks."
What is the difference between StackGuard and StackShield?,"StackGuard and StackShield are both security mechanisms designed to protect against stack-based attacks, but they operate differently. StackGuard primarily uses a 'canary' value placed on the stack to detect buffer overflows. If this canary value is altered, it indicates an overflow, and the program is terminated. StackShield, on the other hand, is a GNU C compiler extension that separates the return address from the data on the stack. It copies the return address to a safe, non-overflowable area upon function call and restores it upon function return, ensuring that even if the stack's return address is corrupted, the original, correct address is used for returning."
How does a format string vulnerability allow an attacker to print values from the stack?,"A format string vulnerability allows an attacker to print values from the stack by exploiting the way functions like `printf` handle format specifiers. When a program uses user-supplied input directly as the format string argument in functions like `printf`, an attacker can insert format specifiers such as `%x` (to print a hexadecimal value) or `%s` (to print a string). The `printf` function then interprets these specifiers and attempts to read data from the stack according to the specifier's type. By carefully crafting a format string with multiple specifiers, an attacker can read arbitrary values from the stack, including security-sensitive information like canaries."
What is the function of the SSP register in Intel CET?,"The SSP register, which stands for Shadow Stack Pointer, is a key component of Intel CET (Control-flow Enforcement Technology). Its primary function is to manage the shadow stack. The shadow stack is a secondary, protected memory area that stores return addresses. The SSP register points to the current top of this shadow stack. During function calls, the return address is pushed onto the shadow stack, and the SSP is updated. During function returns, the return address is popped from the shadow stack, and the SSP is decremented. This ensures that the shadow stack is correctly maintained and that return addresses can be reliably verified against the main stack."
What does it mean for shadow stack pages to have a 'shadow stack' attribute?,"When shadow stack pages have a 'shadow stack' attribute, it signifies a hardware-enforced security measure. This attribute restricts the types of operations that can be performed on these specific memory pages. In the context of a shadow stack, this attribute ensures that only 'call' and 'ret' (return) instructions can read from or write to these pages. This prevents other instructions, such as regular data manipulation or arbitrary code execution, from accessing or modifying the return addresses stored on the shadow stack, thereby protecting its integrity."
How does StackShield ensure the original return address is used even if the stack is altered?,"StackShield ensures the original return address is used even if the stack is altered by maintaining a separate, secure copy. When a function is called, StackShield copies the return address (EIP) from the main stack to a non-overflowable memory area. This copy is protected from being overwritten by buffer overflows. When the function is about to return, StackShield restores this protected, original return address back to the main stack before the program attempts to jump back. Therefore, even if an attacker manages to corrupt the return address currently on the main stack, the correct address will be used for the return jump, neutralizing the attack."
"What is the limitation of StackGuard, Shadow Stack, and StackShield regarding function pointers?","The primary limitation of StackGuard, Shadow Stack, and StackShield is that they are designed to protect the return address, but not other critical pointers within a program, such as function pointers. While these mechanisms effectively prevent attackers from overwriting the return address to hijack control flow, they do not prevent attackers from overwriting function pointers. If a vulnerability allows an attacker to modify a function pointer, they can redirect program execution to malicious code or unintended functions, bypassing the protections offered by these return-address-focused security measures."
What is the purpose of encrypting pointers in PointGuard?,"The purpose of encrypting pointers in PointGuard is to protect them from being overwritten by attackers. By encrypting pointers while they are stored in memory, PointGuard makes them unintelligible and unusable to an attacker who might try to modify them. The encryption is typically done using a secret key and an operation like XOR. The pointer is only decrypted back to its original form when it is loaded into a CPU register for actual use. This significantly reduces the window of opportunity for an attacker to tamper with critical pointers, such as function pointers."
How does PointGuard minimize the window of vulnerability for pointers?,"PointGuard minimizes the window of vulnerability for pointers by ensuring they are only in their original, unencrypted form for the briefest possible duration. Pointers are encrypted when stored in memory. They are then decrypted only when they are loaded into CPU registers for immediate use, such as during a function call. As soon as the operation involving the pointer is complete, it is effectively out of its usable state (either re-encrypted or no longer in active use). This drastically limits the time frame during which an attacker could potentially detect and overwrite a pointer with malicious data."
What happens if an attacker tries to overwrite a pointer with an encrypted malicious address in PointGuard?,"If an attacker tries to overwrite a pointer with an encrypted malicious address in PointGuard, the attack will fail because the attacker does not know the correct secret key. PointGuard encrypts pointers using a randomly generated secret key. Without this key, the attacker cannot generate a valid encrypted form of a malicious function address that would match the expected format or decryption result. When the system attempts to decrypt the attacker's forged pointer, it will not produce the intended malicious address, and the pointer verification will fail, preventing the attack."
What is the role of the Pointer Authentication Code (PAC) in verifying pointer integrity?,"The Pointer Authentication Code (PAC) plays a crucial role in verifying pointer integrity within the Pointer Authentication system. When a pointer is created or updated, a PAC is generated using a cryptographic hash of the pointer's value and a secret key. This PAC is then embedded into the pointer itself. Before the pointer is used, the system recalculates the PAC using the pointer's current value and the same secret key. This recalculated PAC is then compared to the PAC stored within the pointer. If the two PACs match, it confirms that the pointer has not been tampered with since it was signed, and its integrity is assured."
What happens if the PAC values do not match during Pointer Verification?,"If the PAC values do not match during Pointer Verification, it indicates that the pointer's integrity has been compromised. This means that either the pointer's value has been altered since it was signed, or the attacker is attempting to use a forged pointer. In such a scenario, the system will not allow the pointer to be used. The pointer can only be used if the PAC values match, effectively preventing the execution of malicious code through a tampered or invalid pointer."
How does Pointer Authentication prevent attackers from forging PACs?,"Pointer Authentication prevents attackers from forging PACs because the generation of a correct PAC requires knowledge of a secret key. The PAC is created using a cryptographic hash of the pointer's value combined with this secret key. An attacker might be able to alter a pointer's value, but without knowing the secret key, they cannot compute the corresponding valid PAC. Therefore, when the system attempts to verify the pointer, the recalculated PAC will not match the attacker's forged PAC (or lack thereof), and the verification will fail, blocking the attack."
"What are the common limitations of StackGuard, Shadow Stack, and StackShield?","The common limitation of StackGuard, Shadow Stack, and StackShield is that they primarily focus on protecting the return address on the stack. They do not offer protection for other critical pointers, such as function pointers. This means that even if these mechanisms successfully prevent an attacker from overwriting the return address, the attacker might still be able to hijack the program's control flow by exploiting vulnerabilities that allow them to overwrite function pointers."
What is the key idea behind Non-Executable Memory?,"The key idea behind Non-Executable Memory is to prevent attackers from executing malicious code that they inject into a program's memory. Attackers typically inject code into writable memory regions, such as the stack or heap, and then redirect the program's execution flow to this injected code. Non-Executable Memory addresses this by configuring these writable regions as non-executable. This means that even if an attacker successfully places malicious code in memory, the CPU will refuse to execute it, thus thwarting the attack."
How does Intel CET support Shadow Stack?,"Intel CET (Control-flow Enforcement Technology) provides hardware support for Shadow Stack. It introduces a new register called the Shadow Stack Pointer (SSP), which manages the shadow stack. Additionally, CET allows memory pages designated for the shadow stack to be marked with a special 'shadow stack' attribute. This attribute restricts access to these pages, permitting only 'call' and 'ret' instructions to read from or write to them. This hardware-level enforcement ensures the integrity and security of the shadow stack."
What is the purpose of the %n format specifier in format string vulnerabilities?,"The `%n` format specifier in format string vulnerabilities allows an attacker to write data to a memory address. Specifically, it writes the number of bytes that have been successfully written to the output stream so far to the memory location pointed to by the corresponding argument in the `printf` function call. This capability is highly dangerous as it enables attackers to write arbitrary values to arbitrary memory locations, which can be used to overwrite return addresses, function pointers, or other critical data, thereby hijacking program control flow."
What is the difference between pointer encryption and pointer signing?,"Pointer encryption, as used in PointGuard, involves transforming a pointer's value using a secret key (e.g., XOR) so it is unreadable in memory. It is decrypted only when loaded into a CPU register for use. Pointer signing, as used in Pointer Authentication, involves generating a cryptographic signature (PAC) based on the pointer's value and a secret key. This PAC is embedded into the pointer's unused bits. The pointer is then verified by recalculating the PAC and comparing it to the stored one. Encryption obscures the pointer's value, while signing provides a verifiable integrity check."
What is the primary goal of StackGuard?,"The primary goal of StackGuard is to protect against stack buffer overflow vulnerabilities. It achieves this by placing a randomly generated value, known as a 'canary', on the stack before the return address. When a function returns, StackGuard checks if the canary value has been altered. If it has, it indicates that a buffer overflow has occurred, and the program is terminated to prevent potential exploitation, such as overwriting the return address."
