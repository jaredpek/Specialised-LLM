input,output
What is a system call?,A system call is an interface that enables a user-level process to request functions or services from the kernel level.
What types of functions or services can a user-level process request from the kernel level via a system call?,"A user-level process can request functions or services related to process control, file management, and device management from the kernel level via a system call."
How does a user process issue a system call?,"A user process issues a system call by passing the index of the system call and its parameters using an API, typically in the format syscall(SYS_call, arg1, arg2, ...). This process involves interacting with the system call table."
"Define the term ""system call table.""","The system call table is a table of pointers located in the kernel region. These pointers direct to different system call functions, allowing the system to locate and execute the appropriate kernel-level service requested by a user process."
What is the purpose of the syscall API?,"The syscall API, structured as syscall(SYS_call, arg1, arg2, ...), is used by a user process to pass the index of the desired system call (SYS_call) along with any necessary arguments (arg1, arg2, ...) to the kernel, thereby initiating a system call."
What is a Rootkit?,A Rootkit is a type of malware that obtains root privileges to compromise a computer.
What capabilities does a root user have on a compromised system?,"On a compromised system, a root user does not undergo any security checks and can perform any actions to the system. This includes inserting and executing arbitrary malicious code in the system's code path."
How do rootkits hide their existence?,"Rootkits hide their existence by concealing malicious processes, files, and network sockets from being detected by the system."
How can an attacker gain root privileges to deploy a rootkit?,"An attacker can gain root privileges by exploiting vulnerabilities in the software stack, such as buffer overflows or format string vulnerabilities."
What are some examples of vulnerabilities that attackers exploit to gain root privileges?,Attackers can exploit vulnerabilities such as buffer overflow and format string issues in the software stack to gain root privileges.
How does a Rootkit hijack the system-call table?,A Rootkit hijacks the system-call table by changing the pointers of certain entries within it. This redirection causes other processes calling these system calls to execute the attacker's code instead of the legitimate system function.
What is the consequence of a Rootkit changing pointers in the system-call table?,The consequence of a Rootkit changing pointers in the system-call table is that any other processes attempting to call the compromised system calls will inadvertently execute the attacker's malicious code instead of the intended system functions.
Provide an example of a system call that a Rootkit might hijack.,"An example of a system call that a Rootkit might hijack is syscall_open, which is typically used to display running processes (e.g., by the ps command). The Rootkit can redirect this call to a new, malicious function."
Explain the syscall_open redirection example in the context of a Rootkit.,"In the syscall_open redirection example, a Rootkit redirects the syscall_open function to a new_syscall_open function. When the object to be opened matches a malicious name, new_syscall_open returns NULL to hide its existence. Otherwise, it calls the normal old_syscall_open function to maintain system functionality for non-malicious operations."
What is the purpose of new_syscall_open in a Rootkit attack?,"The purpose of new_syscall_open in a Rootkit attack is to intercept calls to the original syscall_open. It checks if the requested object matches a malicious name. If it does, it returns NULL to hide the malicious entity; otherwise, it forwards the call to the legitimate old_syscall_open function."
How does a Rootkit hide a malicious process using new_syscall_open?,"A Rootkit hides a malicious process using new_syscall_open by checking if the object_name being opened matches a predefined malicious name (e.g., ""xingyi"", ""bind_shell"", ""reverse_shell""). If a match is found, the new_syscall_open function returns NULL, effectively preventing the process from being displayed or detected."
"Besides hijacking the system-call table, what other method can a Rootkit use to compromise system call functions?","Besides hijacking the system-call table, a Rootkit can also directly change the system call function itself."
Describe how a Rootkit can directly change a system call function using the syscall_open example.,"In the example of directly changing a system call function, a Rootkit replaces the first 7 bytes of the syscall_open function with a jump instruction to a malicious_open function. This faked system call will first execute the malicious function, then restore the original system call's first 7 bytes, and finally call the correct, original syscall_open function."
What is the role of malicious_open when a Rootkit directly changes a system call function?,"When a Rootkit directly changes a system call function, malicious_open is the function that is executed first. It contains the malicious code that the Rootkit intends to run. After executing its malicious function, malicious_open is responsible for restoring the original system call's code and then calling the legitimate system call."
How does the faked system call ensure the original system call still functions after malicious code execution?,"The faked system call ensures the original system call still functions by first executing its malicious function, then restoring the original system call's initial bytes (which were replaced by a jump instruction), and finally calling the now-restored original system call. This allows the system to proceed with its intended operation while the malicious code has already been executed."
What is the fundamental role of a system call in an operating system?,"The fundamental role of a system call in an operating system is to provide an interface that allows user-level processes to request and access privileged functions and services offered by the kernel level, such as process control, file management, and device management."
Can a user-level process directly access kernel-level functions?,"No, a user-level process cannot directly access kernel-level functions. Instead, it must use a system call as an interface to request these functions or services from the kernel level."
What information does a user process pass when issuing a system call?,"When issuing a system call, a user process passes the index of the specific system call it wishes to invoke, along with any necessary parameters required by that system call function. This is done via an API like syscall(SYS_call, arg1, arg2, ...)."
Where are the pointers to system call functions stored?,"The pointers to different system call functions are stored in the system call table, which resides in the kernel region of the system's memory."
"What does it mean for malware to ""obtain root privileges""?","For malware to ""obtain root privileges"" means it gains the highest level of administrative access on a computer. This allows the malware, specifically a Rootkit, to bypass security checks and perform any action on the system, including executing arbitrary malicious code and hiding its presence."
What are the two main malicious actions a root user can perform as described?,"As described, the two main malicious actions a root user can perform are: 1) inserting and executing arbitrary malicious code in the system's code path, and 2) hiding its existence, such as malicious processes, files, or network sockets, from being detected."
Why is a root user particularly dangerous in the context of a Rootkit?,"A root user is particularly dangerous in the context of a Rootkit because they do not go through any security checks and can perform any actions to the system. This unrestricted access allows the Rootkit to deeply embed itself, execute malicious code, and effectively hide its presence."
"What is a ""software stack vulnerability""?","A ""software stack vulnerability"" refers to weaknesses in the software's design or implementation, such as buffer overflows or format string bugs, that can be exploited by an attacker to gain unauthorized access or control, often leading to the acquisition of root privileges."
How does a Rootkit ensure its malicious code is executed when a legitimate system call is made?,"A Rootkit ensures its malicious code is executed when a legitimate system call is made by changing the pointers in the system-call table. When a process attempts to call the legitimate system call, the modified pointer redirects the execution flow to the attacker's code instead."
What is the significance of __NR_open in the context of system call hijacking?,"__NR_open is a symbolic constant representing the index of the open system call. In the context of system call hijacking, a Rootkit uses this index to locate the pointer for syscall_open in the system call table and then modifies it to point to a new_syscall_open function, thereby redirecting the system call."
How does the new_syscall_open function decide whether to hide an object or call the original system call?,"The new_syscall_open function decides whether to hide an object or call the original system call by checking if the object_name passed to it matches any of the predefined malicious_object_name entries. If a match is found, it returns NULL to hide the object; otherwise, it proceeds to call the old_syscall_open function."
What are some examples of malicious_object_name that a Rootkit might look for?,"Some examples of malicious_object_name that a Rootkit might look for to hide include ""xingyi"", ""bind_shell"", and ""reverse_shell"". These names likely correspond to malicious processes, files, or network connections."
What is the initial step a Rootkit takes when directly changing a system call function like syscall_open?,The initial step a Rootkit takes when directly changing a system call function like syscall_open is to replace the first 7 bytes of the syscall_open function's code with a jump instruction that redirects execution to a malicious_open function.
Why does the Rootkit restore the original system call's code after executing its malicious function?,The Rootkit restores the original system call's code after executing its malicious function to ensure that the legitimate system call can still be executed correctly. This allows the system to maintain normal operation while the Rootkit's malicious payload has already been delivered.
What is the purpose of old_syscall_code in the direct system call function modification technique?,"old_syscall_code is used to store the original first 7 bytes of the syscall_open function. These bytes are saved before being overwritten by the jump instruction to malicious_open, and are later restored to allow the original syscall_open to execute properly."
How many bytes are typically replaced at the beginning of a system call function in the direct modification method?,"In the direct modification method, typically the first 7 bytes of a system call function, such as syscall_open, are replaced to insert a jump instruction to the malicious function."
What are the three categories of services mentioned that system calls provide?,"The three categories of services mentioned that system calls provide are Process control, File management, and Device management."
Explain the relationship between a user-level process and the kernel level in the context of system calls.,"In the context of system calls, a user-level process operates in a less privileged mode and cannot directly access hardware or critical system resources. It relies on the kernel level, which operates in a privileged mode, to perform these operations. A system call acts as the secure interface for the user-level process to request these privileged functions or services from the kernel."
What is the primary objective of a Rootkit?,"The primary objective of a Rootkit is to compromise a computer by obtaining root privileges, which grants it unrestricted access and control over the system."
Can a Rootkit operate without gaining root privileges?,"The document defines a Rootkit as ""Malware that obtains root privileges to compromise the computer,"" implying that gaining root privileges is a defining characteristic and necessary for its described operations. Therefore, based on this definition, a Rootkit operates by obtaining root privileges."
What is the ultimate goal of a Rootkit when it hijacks the system-call table?,"The ultimate goal of a Rootkit when it hijacks the system-call table is to execute the attacker's code whenever other processes call the compromised system calls, thereby gaining control over system operations and potentially hiding its malicious activities."
How does the ps command relate to syscall_open in the example?,"In the example, syscall_open is mentioned as being used to display the running process, which is a function typically performed by commands like ps. This illustrates how a Rootkit can hijack a system call fundamental to system monitoring."
What happens if new_syscall_open does not find a match for a malicious object name?,"If new_syscall_open does not find a match for a malicious object name, it proceeds to call the normal old_syscall_open function. This ensures that legitimate system operations continue to function as expected, preventing detection of the Rootkit."
What is the purpose of the memncpy function calls in the direct system call modification code?,"The memncpy function calls in the direct system call modification code serve two main purposes: first, to save the original first 7 bytes of syscall_open into old_syscall_code, and second, to overwrite those first 7 bytes with the new_syscall_code (which contains the jump instruction to malicious_open). Later, memncpy is used again to restore the original 7 bytes."
"What is the significance of the ""\xbd"",pt[0],pt[1],pt[2], pt[3], // movl %pt, %ebp ""\xff"",""\xe5"" // jmp %ebp sequence?","This sequence represents the new_syscall_code which is a 7-byte instruction. Specifically, ""\xbd"",pt[0],pt[1],pt[2], pt[3] corresponds to movl %pt, %ebp, which moves the address of the malicious function into the %ebp register. ""\xff"",""\xe5"" corresponds to jmp %ebp, which then jumps to the address stored in %ebp, effectively redirecting execution to the malicious_open function."
What is the role of SYS_call in the syscall API?,"In the syscall API, SYS_call represents the index of the specific system call function that the user process intends to request from the kernel. This index is used by the system to look up the correct function pointer in the system call table."
Why is it important for a Rootkit to hide its existence?,"It is important for a Rootkit to hide its existence to avoid detection. By concealing malicious processes, files, and network sockets, the Rootkit can maintain persistence and continue its malicious activities without being discovered and removed from the compromised system."
How does a Rootkit use the syscall_addr array in the system call table hijacking?,"A Rootkit uses the syscall_addr array, which points to the system call table, to first read the original pointer for __NR_open (saving it as old_syscall_open) and then to overwrite that entry with the pointer to new_syscall_open. This effectively redirects calls to syscall_open."
What is the purpose of malicious_function() within malicious_open?,The malicious_function() within malicious_open is where the Rootkit's specific malicious payload or actions are executed. This is the core part of the attack where the Rootkit performs its intended harmful operations before restoring the original system call.
How does the direct system call function modification technique differ from the system-call table hijacking technique?,"The direct system call function modification technique differs from system-call table hijacking in that it directly alters the initial bytes of the system call function itself to insert a jump instruction to malicious code. In contrast, system-call table hijacking modifies the pointer in the system-call table to redirect to a new function, but doesn't necessarily alter the original system call's code directly at its entry point. Both achieve redirection but through different mechanisms."
